generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          String    @default("PARENT") // UserRole: ADMIN, TEACHER, PARENT
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts Account[]
  sessions Session[]

  // Relations
  students Student[] // For PARENT role: children
  batches  Batch[] // For TEACHER role: assigned batches
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Student {
  id            String   @id @default(cuid())
  name          String
  dob           DateTime
  gender        String // Gender: MALE, FEMALE, OTHER
  contactNumber String?
  email         String? // Optional student email
  address       String?
  joiningDate   DateTime @default(now())
  level         String? // Abacus level
  active        Boolean  @default(true)

  parentId String?
  parent   User?   @relation(fields: [parentId], references: [id])

  batchId String?
  batch   Batch?  @relation(fields: [batchId], references: [id])

  attendance Attendance[]
  feeRecords FeeRecord[]
  documents  Document[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Batch {
  id        String   @id @default(cuid())
  name      String
  level     String?
  days      String // Stored as comma-separated string or JSON since SQLite doesn't support arrays
  timeSlot  String? // e.g. "17:00-18:00"
  teacherId String?
  teacher   User?    @relation(fields: [teacherId], references: [id])

  students   Student[]
  attendance Attendance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Attendance {
  id        String   @id @default(cuid())
  date      DateTime
  status    String // AttendanceStatus: PRESENT, ABSENT, LATE
  studentId String
  student   Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)
  batchId   String
  batch     Batch    @relation(fields: [batchId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([date, studentId, batchId]) // One record per student per batch per day
}

model FeeRecord {
  id        String    @id @default(cuid())
  studentId String
  student   Student   @relation(fields: [studentId], references: [id], onDelete: Cascade)
  amount    Float
  dueDate   DateTime
  paidDate  DateTime?
  status    String    @default("PENDING") // FeeStatus: PENDING, PAID, OVERDUE
  cycle     String    @default("MONTHLY") // FeeCycle: MONTHLY, QUARTERLY, HALF_YEARLY, YEARLY
  year      Int
  month     Int? // 1-12, for monthly
  remarks   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Document {
  id        String   @id @default(cuid())
  name      String
  url       String
  type      String?
  studentId String
  student   Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
